#!/bin/sh

if [ $# -ne 2 ]
then
	echo "Usage: timeconst.sh HZ FILENAME"
	echo
	echo "Generate a header file with constants for coverting between"
	echo "decimal HZ timer ticks and milisecond or microsecond delays."
	echo
	exit 1
fi

HZ=$1
shift
FILENAME=$1

# Sanity test: even the shell in Red Hat 9 (circa 2003) supported 64 bit math.

if [ $((1 << 32)) -lt 0 ]
then
	echo "timeconst.sh needs a shell with 64 bit math, such as bash,"
	echo "busybox ash, or dash running on a 64 bit host."
	exit 1
fi

# If this script exits for any reason before this trap is removed,
# delete the output file so a partial file won't confuse the build.

trap "rm $FILENAME" EXIT

# Output start of header file

cat > $FILENAME << EOF || exit 1
/* Automatically generated by kernel/timeconst.sh */
/* Conversion constants for HZ == $HZ */

#ifndef __KERNEL_TIMECONST_H
#define __KERNEL_TIMECONST_H

#include <linux/param.h>
#include <linux/types.h>

#if HZ != $HZ
#error "kernel/timeconst.h has the wrong HZ value!"
#endif

EOF

# For both Milliseconds and Microseconds

cat << EOF |
MSEC 1000
USEC 1000000
EOF
while read NAME PERIOD
do
	# Find greatest common denominator (using Euclid's algorithm)

	A=$HZ
	B=$PERIOD

	while [ $B -ne 0 ]
	do
		C=$(( $A % $B ))
		A=$B
		B=$C
	done

	GCD=$A

	# Do this for each direction (HZ_TO_PERIOD and PERIOD_TO_HZ)

	for DIRECTION in 0 1
	do
		if [ $DIRECTION -eq 0 ]
		then
			CONVERT="HZ_TO_${NAME}"
			FROM=$HZ
			TO=$PERIOD
		else
			CONVERT="${NAME}_TO_HZ"
			FROM=$PERIOD
			TO=$HZ
		fi

		# Calculate 32 significant bits of MUL32 data.

		SHIFT=0
		while true
		do
			# This can't overflow 64 bit math.  Pathological case
			# (TO=1, FROM=1000000) uses around 32+20=52 bits.

			MUL32=$(( ( ( $TO << $SHIFT ) + $FROM - 1 ) / $FROM ))

			# Keep increasing $SHIFT until we've got 32 bits.

			[ $MUL32 -gt $(( 1 << 31 )) ] && break
			SHIFT=$(( $SHIFT + 1 ))
		done
		MUL32=$( printf %x $MUL32 )

		# ADJ32 is just (((FROM/GCD)-1)<<SHIFT)/(FROM/GCD) but this
		# can overflow 64 bit math (examples, HZ=24 or HZ=122).
		# Pathological case could use 32+20+20=72 bits.  (And this is
		# the pathological case because a larger $HZ results in a
		# smaller $SHIFT, so even insane HZ>USEC cases should be ok.)

		# To get around this, we chop the bottom 32 bits off the
		# calculation and then reassemble it to avoid overflow:
		# 32+64=96, which is > 72.

		ADJ32=$(( $FROM / $GCD ))
		if [ $SHIFT -gt 32 ]
		then
			UPPER=$(( ( $ADJ32 - 1 ) << ( $SHIFT - 32 ) ))
			LOWER=$(( ( $UPPER % $ADJ32 ) << 32 ))
			ADJ32=$(( ( ( $UPPER / $ADJ32 ) << 32 ) + ( $LOWER / $ADJ32 )))
		else
			ADJ32=$(( ( ( $ADJ32 - 1 ) << $SHIFT) / $ADJ32 ))
		fi
		ADJ32=$( printf %x $ADJ32 )

		NUM=$(( $TO / $GCD ))
		DEN=$(( $FROM / $GCD ))

		# Output next chunk of header data to file

		(
			echo "#define ${CONVERT}_MUL32	U64_C(0x$MUL32)" &&
			echo "#define ${CONVERT}_ADJ32	U64_C(0x$ADJ32)" &&
			echo "#define ${CONVERT}_SHR32	$SHIFT" &&
			echo "#define ${CONVERT}_NUM		U64_C($NUM)" &&
			echo "#define ${CONVERT}_DEN		U64_C($DEN)"
		) >> $FILENAME || exit 1
	done
done

(
	echo
	echo "#endif /* __KERNEL_TIMECHONST_H */"
) >> $FILENAME || exit 1

# Don't rm $FILENAME on exit anymore.

trap "" EXIT

exit 0
